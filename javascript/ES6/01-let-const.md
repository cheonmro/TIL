# Javascript let, const

angular, ECMAScript는
version 3이 없다.

ECMAScript: 3 -> 5 version
jason
strict mode

js 위상이 높아짐 -> 고 어플리케이션

1년에 한번씩 버전 1씩 올라감

ECMAScript6의 문법을 브라우저들이 어느정도 지원하고 있는지?
-> ecmascript browser support

--

폴더: 네임스페이스 -> 폴더내에서는 어떠한 이름도 가능(다른 폴더내의 같은이름을 사용해도 가능)


'let'('const')도 호이스팅이 일어난다.
자바스크립트는 모든 선언문을 호이스팅을 한다.
그러나 호이스팅의 동작이 조금씩 다른다.

'let'('const') -> 호이스팅이 일어나는데, 일어나지 않는 것 처럼 동작한다.

문법적 설탕: ES5에서 어려웠던 내용을 좀 더 개선하여 만든 ES6의 문법 등과 같은 상황을 말한다.



## 1.4 클로저

for문에서 () 안의 let은 함수의 매개변수와 같은 기능이기 때문에, let은 지역변수이다.
```
for (let i = 0; i < 3; i++) {
  funcs.push(function () { console.log(i); });
}
```
외부함수 & 내부함수 -> 함수별 스코프기 때문에, 클로저!

위 코드에서 보면,
외부 스코프가 있고
내부 스포크가 있다.
내부 스코프에 있는 변수가 외부 스코프에 있는 변수를 참조한다. 즉, 이게 let을 이용한 클로저이다.

ES6에서 클로저가 없어진게 아니고, 위와 같이 있다.


ES5 와 ES6의 실행컨텍스트가 조금 다르다.


# 2. const

**중요

const에 객체를 할당할 경우,
재할당이 안된다. -> 주소를 못 고친다.
주소가 안 바뀌고, 값만 바뀌면(값만 변경하면)? 값을 변경가능 

**중요
## 2.3 const와 객체

-> 5.8 객체와 변경불가성: 공부하기

원본 객체와 변경된 객체를 비교. 
예) todos.map을 활용하여 새로운 변수를 선언하면, 새로운 배열이 반환된 상태라 새로 변경된 배열이다.


코드할 때 생각하는 순서
1. 개발자: 어떤 데이터 구조를 가지고 있어야 하지?(퍼블리셔: dom을 어떻게 하지?)

html을 고치면 로직에 영향을 준다.


코드 순서
1. DOM에서 가져오기
2. <div></div> 데이터를 관리해야 한다. -> 서버에서 데이터 구조를 가지고 있어야 한다. 
  1. var count = 0; 작성
  2. count를 서버에 보내주면 된다.
3. addEventListner 사용
  1. 여기에 count를 사용
4. ++count, render()
5. render() {
  document.querySelector(').innerHTML = count;
}
1. todos 데이터가 상태 데이터이다. 
2. count를 상태라고 한다.(count가 todos와 같다.)
3. (유저를 통해) 이벤트를 실행 -> 상태가 변한다.(render) -> 상태데이터가 dom을 일치시킨다.


DOM을 데이터구조(count = 0)로 가지고 있는다. 
이 데이터를 가지고 오고, 활용하고

'상태'에 대해 알기

const가 재할당이 안된다는 것은 주소를 그대로 써라. 대신, 객체 값은 변경가능하다.


상태가 바뀌면 -> DOM이 바뀐다.

주소가 바뀌면 상태가 바로 바꼈다고 알기 쉬움

변경
- 주소
- 값

객체의 경우, 주소가 바껴야 변경되는 것(값이 변경되는 것은 그냥 내용이 바뀐것)


실제로, 객체의 주소를 바꿀 경우가 거의 없다.


## 3. var vs. let vs. const

var는 절대 사용하지 않는다.

재할당이 필요한 변수란?

대부분의 객체는 재할당이 필요 없다.


