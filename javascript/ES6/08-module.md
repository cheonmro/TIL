# ES6 Module

# Module 정리

## 1. Introduction

모듈이란, 애플리케이션의 개별 구성 요소로써, 재사용을 위한 코드 조각이고, 주로 파일 단위로 분리되어있다.

애플리케이션을 개발하면서 필요한 기능을 가져가 쓸 때, 직접 개발하는 것이 아닌, 미리 만들어논 모듈을 로드하여 사용한다.
즉, 모듈은 개별적으로 존재하다가 필요시에 애플리케이션에서 로드를 통해 사용된다.
이런 방식은 개발효율성 및 유지보수성의 향상에 도움이 된다.

자바스크립트 언어의 초창기 만들어진 목적이 웹페이지 제작을 위한 보조적인 역할이었기 때문에, 다른 언어에 비해 부족한 부분들이 있다.
그 중 대표적인 것이 모듈 기능이 없는 것이다.

그대신, 자바스크립트의 경우 html의 파일내에 script 태그를 사용하여 외부에서 자바스크립트 파일을 가져와서 사용한다.
그러나, 각 자바스크립트 파일마다 독립적인 스코프를 갖지 않고, 하나의 전역 객체에 바인딩된다.
즉, 스코프가 전역으로 단 1개이기 때문에, 전역변수의 중복 등 이름들이 충돌되는 문제가 발생하게 되어, 이것으로는 모듈화를 구현할 수가 없다.

이런 문제를 해결하기 위해 제안된 것이 CommonJS와 AMD이다.

서버 사이드의 Node.js에서는 사실상 표준인 CommonJS를 채택했다.

ES6에서는 클라이언트 사이트에서도 동작하는 모듈 기능을 추가했다.
단, 현재 대부분의 브라우저가 ES6의 모듈을 지원하지 않고 있기 때문에, ES6 모듈을 현재의 브라우저에서 사용하기 위해서는
모듈 로더(SystemJS, RequireJS) 또는 모듈 번들러(Webpack) 등을 사용해야 한다.

ES6 모듈과 관련된 키워드는 export, import가 있다.

<br>

## 2. export & import

각 모듈은 하나의 파일로써, 독립적인 스코프를 갖기 때문에 모듈 안에 선언한 모든 것들은 기본적으로 해당 모듈 내부에서만 참조 가능하다.
모듈 안에 선언한 항목을 외부에 공개하여 다른 모듈들이 사용할 수 있게 하기 위해서는, 선언문 앞에 export를 사용해야 한다.

외부에 공개한 모듈을 로드하여 사용하려면, import를 사용해야 한다.


<br>

## 참고사항

html 파일에 script 태그의 순서는 유의미.
하나의 전역, 하나의 파일로 합쳐진다.?
문제: 변수 중복 등 문제가 생긴다.
어떻게 개선? 

예)
현상: 이름의 충돌
원인: 전역의 하나, 스코프가 전역 1개다.
(지속적인) 개선: 파일별로 스코프를 나눈다. -> IIFE: return 할때, 생성자 함수를 생성하게 한다.

--> 더 좋은 방법? Module

<br>

# 1. Introduction

왜 개별적 요소로 분리하나? 재사용(돈 === 리소스(자원), 품질 등을 효율적으로 사용하기 위해)

공학: 어떻게 하면 저비용으로 효율적으로 물질적 세계에 적용

재사용
- 함수
- 모듈


(기본) 원칙: 관심사의 분리 -> html/css/js
그러나, 최근에는 이런 원칙이 무너졌다. -> (Angulr)의 CBD 개념 도입(컴포넌트 기반) -> 즉, 크게 보면 관심사가 같다.(단, 분업의 의미가 있다.)
-> 그럼 이 3개를 뭉치자 -> 부품화 방식으로


애플리케이션은 모두 모듈이 있어야 한다.

범용적으로 사용하고자 하는 움직임: 모듈 기능에 대한 문제점을 해결하려 한다.
- CommonJS(더 많이 사용한다.)
- AMD

node.js -> CommonJS로 모듈화를 구현해 놓음

모듈은 스펙에만 있고, 어떤 브라우저에서도 구현되어 있지 않다.(지원되지 않는다.)

그래서, 현재 브라우저에서는 export, import를 사용 못한다.(지원 안한다.)

그래서, 다른 방법을 찾아야 한다.
- SystemJS
- RequireJS
- WebPack

애플리케이션을 위해서는, 위 3가지 중 한가지를 사용해야 한다.

<br>


# 2. export

(외부에) 공개한다.


<br>

# 3. import

```
import { pi, square, Person } from './lib';
```
-> 객체 디스트럭처링

```
import * as lib from './lib';
```
lib와 './lib' 모두 객체


default는 1개 일때만, 사용


export가 있으면, 얘를 모듈로 간주한다.