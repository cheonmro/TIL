# ES6 Promise

Q: 비동기 함수는 실행 완료를 기다리지 않고, 다음 task를 실행한다.
따라서, 비동기 함수 내에서 처리 결과를 return하면 기대한 대로 동작하지 않는다. ??
즉, 함수의 실행이 완료하여 함수의 반환값을 받기 이전에 다음 task로 진행된다. 




## 1. 프로미스란?

기존의 약점(문제점)
- 콜백헬이라는 현상 발생
- 에러처리가 불가능하다.

## 2. 콜백 패턴의 단점

비동기 시간은 어떻게 처리할까?

싱글 쓰레드 v. 멀티 쓰레드

동기식 처리 모델: 싱글 쓰레드 -> Blocking!

비동기식 처리 모델: 순서를 추적하기가 어렵다.

비동기식은 순서가 보장되지 않는다.
결과를 기다리지 않고, 그 다음으로 넘어가서, 반환이 안된다.
그래서 함수 내부에서 처리를 해줘야 한다.

자바스크립트 intent(띄어쓰기)가 2칸


## 2.2 에러 처리의 한계

자바스크립트는 try catch를 거의 안쓴다.
비동기 처리의 에러를 처리 못하기 때문에.
왜 안되냐? 
에러는 에러 발생원()과 에러 캐치원
호출자에게 에러를 전파하게 되어있다.
그래서, 이것은 현업에서 못쓴다.


# 3. 프로미스의 생성

이것도 약점이 있다.
이것도 일부 쓰긴 하지만, 구식이다.
안쓰면 될 것 같지만, 인기 있는 라이브러리가 프로미스를 사용하기 때문에 배워야 한다.

어웨이트 어씽크(ES7): 좀 더 좋은 것(그러나, 이것도 조금 그렇다.)

RxJS: 비동기 처리의 최신



```
// Promise 객체의 생성
const promise = new Promise((resolve, reject) => { // 이 함수를 왜 인자(resolve, reject)로 주었나?
  // 비동기 작업을 수행한다.

  if (/* 비동기 작업 수행 성공 */) {
    resolve('result');
  }
  else { /* 비동기 작업 수행 실패 */
    reject('failure reason');
  }
});
```

map이 안에 있는 콜백함수를 호출
todos.map(todo => todo.id);

Promise(호출자)이 안에 있는 콜백함수를 호출(매개변수에 함수를 준다.)
const promise = new Promise((resolve, reject) =>


Promise 객체를 만드는데, 콜백함수를 호출하고, 인자로 resolve, reject를 준다.
예전대로, 비동기 처리를 하지만, 
성공하면 -> resolve(성공했을 때의 값을 담아주기)
실패하면 -> reject(error 메세지로 담아주기)


then, catch 한번씩 쓰는 이 방식으로 (우선) 코딩하자.

